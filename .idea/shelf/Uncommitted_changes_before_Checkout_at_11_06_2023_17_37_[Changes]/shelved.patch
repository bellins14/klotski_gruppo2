Index: src/main/java/com/klotski/app/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.klotski.app;\r\n\r\nimport java.util.Stack;\r\n\r\nimport static com.klotski.app.Constants.*;\r\n\r\n\r\n/**\r\n * Classe che rappresenta lo stato del gioco di Klotski. Dispone:\r\n * - del numero della configurazione di partenza (tra le 4 iniziali),\r\n * - della configurazione attuale dei pezzi,\r\n * - di un contatore delle mosse (a partire dalla configurazione iniziale)\r\n * - del path del file di log (o storico o database) dove è salvata la partita (sotto forma di configurazioni)\r\n * - del path del file di supporto per la serializzazione/deserializzazione in json della configurazione attuale\r\n */\r\npublic class Game {\r\n    /**\r\n     * Indica quale configurazione iniziale è selezionata tra le 4 disponibili\r\n     *\r\n     */\r\n    private int _initialSelectedConf;\r\n    /**\r\n     * Configurazione attuale del gioco\r\n     *\r\n     */\r\n    private Configuration _configuration;\r\n    /**\r\n     * Contatore delle mosse\r\n     *\r\n     */\r\n    private int _moveCounter;\r\n\r\n    /**\r\n     * Stack di configurazioni\r\n     * funge da log (un simil database) per il gioco\r\n     * ed è sincronizzato con il file di Log ConfigurationLog\r\n     */\r\n    private Stack<Configuration> _stackLog;\r\n\r\n    /**\r\n     * Path del file di log dove con cui sincronizzare _stackLog\r\n     * e che funge da storico delle mosse\r\n     */\r\n    private final String _logFilePathName;\r\n\r\n    /**\r\n     * Path del file di supporto per le serializzazione in json delle Configurazioni\r\n     *\r\n     */\r\n    private final String _supportFilePathName;\r\n\r\n\r\n    /**\r\n     * Costruttore di default\r\n     * Crea un gioco a partire dal file di log, e da un file di supporto per la serializzazione delle configurazioni\r\n     * - se c'è una partita precedente la riprende\r\n     * - altrimenti crea il gioco dalla configurazione iniziale di default (la numero 1)\r\n     *\r\n     * @param logFilePathName     file di log (json) (se non esiste già viene creato)\r\n     * @param supportFilePathName file di supporto (json) (se non esiste già viene creato)\r\n     */\r\n    public Game(String logFilePathName, String supportFilePathName) {\r\n\r\n        //Inizializza i path dei file\r\n        _logFilePathName = logFilePathName;\r\n        _supportFilePathName = supportFilePathName;\r\n\r\n        //Crea lo stack log\r\n        _stackLog = new Stack<>();\r\n\r\n        //Inizializza lo stack log con il file log\r\n        _stackLog = UtilityJackson.deserializeConfigurationLog(_logFilePathName);\r\n\r\n        if (_stackLog.size() == EMPTY_LOG_SIZE) { // Se il log è vuoto\r\n\r\n            //Inizializza il gioco con la configurazione default (la numero 1)\r\n            _initialSelectedConf = 1;\r\n            _configuration = new Configuration(_initialSelectedConf);\r\n\r\n            //Aggiorna sia lo Stack che il file di log, inserendo la configurazione corrente\r\n            updateLogsWithCurrentConfiguration();\r\n\r\n            //Setta il counter delle mosse a 0\r\n            _moveCounter = 0;\r\n\r\n        } else if (_stackLog.size() == SINGLE_LOG_SIZE) { // Nel log c'è solo una configurazione, quella iniziale\r\n            // => c'è una partita precedente allo stadio iniziale\r\n\r\n            //Prende tale configurazione (in json) dal file di log, la converte in un oggetto Configuration\r\n            // e inizializza _configuration\r\n            _configuration = UtilityJackson.deserializeConfiguration(_supportFilePathName);\r\n\r\n            //Controlla che sia una delle 4 configurazioni iniziali, prendi il numero e setta selectedConf\r\n            _initialSelectedConf = Configuration.isInitialConfiguration(_configuration);\r\n\r\n            //Setta il counter delle mosse a 0\r\n            _moveCounter = 0;\r\n\r\n        } else { //Se nel log c'è più di una configurazione => c'è una partita precedente avanzata\r\n\r\n            //Ripristina la partita precedente:\r\n            //Recupera dallo stack di log la configurazione iniziale e inizializza la configurazione attuale\r\n            _configuration = getInitConfiguration();\r\n\r\n            //Controlla a quale numero di configurazione iniziale corrisponde e setta selectedConf\r\n            _initialSelectedConf = Configuration.isInitialConfiguration(_configuration);\r\n\r\n            //Prende l'ultima configurazione (in formato json) e la salva nel file di supporto (DC_FILE)\r\n            UtilityJackson.serializeConfiguration(_stackLog.peek(), _supportFilePathName);\r\n\r\n            //Prende la configurazione dal file di supporto (json), crea un (oggetto) configurazione e inizializza\r\n            // la configurazione corrente\r\n            _configuration = UtilityJackson.deserializeConfiguration(_supportFilePathName);\r\n\r\n            //Ripristina il contatore delle mosse\r\n            _moveCounter = _stackLog.size() - 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Metodo per ritornare il numero della configurazione iniziale associata alla configurazione attuale\r\n     *\r\n     * @return _initialSelectedConf\r\n     */\r\n    public int getInitialSelectedConf() {\r\n        return _initialSelectedConf;\r\n    }\r\n\r\n    /**\r\n     * Metodo per ritornare la configurazione attuale\r\n     *\r\n     * @return _configuration\r\n     */\r\n    public Configuration getConfiguration() {\r\n        return _configuration;\r\n    }\r\n\r\n    /**\r\n     * Metodo per settare la configurazione attuale con la nuova configurazione passata\r\n     *\r\n     * @param newConfiguration nuova configurazione passata\r\n     */\r\n    public void setConfiguration(Configuration newConfiguration) {\r\n        this._configuration = newConfiguration;\r\n\r\n        //Inserisci la nuova configurazione nello Stack e nel file di log\r\n        updateLogsWithCurrentConfiguration();\r\n    }\r\n\r\n    /**\r\n     * Metodo per ritornare il counter delle mosse\r\n     *\r\n     * @return _moveCounter\r\n     */\r\n    public int getMoveCounter() {\r\n        return this._moveCounter;\r\n    }\r\n\r\n    /**\r\n     * Metodo chiamato alla pressione delle frecce o dei tasti ASDW con blocco selezionato\r\n     * Muove il pezzo selezionato nella direzione designata di 100px, se possibile, altrimenti termina silenziosamente\r\n     * @param movingPiece pezzo da muovere\r\n     * @param dirIdx direzione in cui muoverlo\r\n     * @throws Exception se la partita si trova in una configurazione di vittoria\r\n     * @throws IllegalArgumentException se il blocco non appartiene alla config attuale del gioco\r\n     */\r\n\r\n    public void movePiece(Piece movingPiece, int dirIdx) throws Exception{\r\n\r\n        //Verifica che il pezzo appartenga alla configurazione\r\n        if (!_configuration.doesPieceBelong(movingPiece)) {\r\n            throw new IllegalArgumentException(\"Il pezzo non appartiene alla configurazione attuale del gioco\");\r\n        }\r\n\r\n        //In base alla direzione in cui si intende muover il pezzo\r\n        switch (dirIdx) {\r\n\r\n            //DOWN\r\n            case S, ARROW_DOWN -> {\r\n                if (movingPiece.getLayoutY() + MOVE_AMOUNT + movingPiece.getHeight() <= MAX_PANE_HEIGHT\r\n                        && Utility.isNotOverlapping(movingPiece, _configuration, 0, MOVE_AMOUNT)) {\r\n                    //Muove il pezzo in giu\r\n                    movePieceDown(movingPiece);\r\n                }\r\n            }\r\n            //RIGHT\r\n            case D, ARROW_RIGHT -> {\r\n                if (movingPiece.getLayoutX() + MOVE_AMOUNT + movingPiece.getWidth() <= MAX_PANE_WIDTH\r\n                        && Utility.isNotOverlapping(movingPiece, _configuration, MOVE_AMOUNT, 0)) {\r\n                    //Muove il pezzo a dx\r\n                    movePieceRight(movingPiece);\r\n                }\r\n            }\r\n            //UP\r\n            case W, ARROW_UP -> {\r\n                if (movingPiece.getLayoutY() - MOVE_AMOUNT >= 0 && Utility.isNotOverlapping(movingPiece, _configuration, 0, -MOVE_AMOUNT)) {\r\n                    //Muove il pezzo in alto\r\n                    movePieceUp(movingPiece);\r\n                }\r\n            }\r\n            //LEFT\r\n            case A, ARROW_LEFT -> {\r\n                if (movingPiece.getLayoutX() - MOVE_AMOUNT >= 0 && Utility.isNotOverlapping(movingPiece, _configuration, -MOVE_AMOUNT, 0)) {\r\n                    //Muove il pezzo a sx\r\n                    movePieceLeft(movingPiece);\r\n                }\r\n            }\r\n        }\r\n\r\n        checkNotWin();\r\n    }\r\n\r\n    /**\r\n     * Metodo che resetta il gioco ad una configurazione iniziale:\r\n     * setta la configurazione corrente con una delle 4 configurazioni iniziali, diversa da quella iniziale corrente\r\n     * e resetta e aggiorna il log.\r\n     *\r\n     * @param confNumber configurazione iniziale a cui settare il gioco\r\n     * @throws Exception se confNumber la configurazione iniziale passata è la configurazione iniziale corrente\r\n     */\r\n    public void resetToAnotherInitialConf(int confNumber) throws Exception {\r\n\r\n        //Se la configurazione iniziale passata è la configurazione iniziale corrente oppure non è tra le 4 iniziali, lancia eccezione\r\n        if(confNumber == _initialSelectedConf || confNumber>4 || confNumber <1){\r\n            throw new Exception();\r\n        }\r\n\r\n        //Altrimenti\r\n        //Crea la nuova configurazione iniziale\r\n        Configuration newInitialConfiguration = new Configuration(confNumber); //Lancia IllegalArgumentException se confNumber <1 o >4\r\n\r\n        //Se è stata creata la nuova configurazione iniziale\r\n        //Pulisci lo Stack di log\r\n        _stackLog.clear();\r\n\r\n        //Aggiorna la configurazione attuale con la nuova configurazione iniziale\r\n        setConfiguration(newInitialConfiguration);\r\n\r\n        //Resetta il counter delle mosse\r\n        _moveCounter = 0;\r\n\r\n        //Aggiorna il numero della configurazione iniziale scelta\r\n        setInitialSelectedConf(confNumber);\r\n\r\n    }\r\n\r\n    /**\r\n     * Metodo che resetta il gioco: setta la configurazione corrente con la sua configurazione iniziale\r\n     * e resetta e aggiorna il log\r\n     */\r\n    public void reset(){\r\n\r\n        //Crea la nuova configurazione iniziale\r\n        Configuration newInitialConfiguration = new Configuration(_initialSelectedConf); //Lancia IllegalArgumentException se confNumber <1 o >4\r\n\r\n        //Se è stata creata la nuova configurazione iniziale\r\n        //Pulisci lo Stack di log\r\n        _stackLog.clear();\r\n\r\n        //Aggiorna la configurazione attuale con la nuova configurazione iniziale\r\n        setConfiguration(newInitialConfiguration);\r\n\r\n        //Resetta il counter delle mosse\r\n        _moveCounter = 0;\r\n\r\n    }\r\n\r\n    /**\r\n     * Metodo che fa un undo: setta la configurazione corrente con la configurazione precedente, che viene presa dal log che viene aggiornato\r\n     *\r\n     * @throws Exception se non è disponibile nessuna configurazione precedente\r\n     */\r\n    public void undo() throws Exception {\r\n\r\n        //Togli temporaneamente la configurazione attuale dallo Stack di log\r\n        Configuration currentConfiguration = this._stackLog.pop();\r\n\r\n        if (this._stackLog.isEmpty()) { //Se non ci sono configurazioni precedenti sullo Stack di log\r\n            //Rimetti la configurazione corrente sullo Stack di log\r\n            this._stackLog.push(currentConfiguration);\r\n            throw new Exception();\r\n        }\r\n\r\n        //Altrimenti\r\n        //Aggiorna la configurazione attuale con la configurazione precedente e aggiorna lo Stack di log e il file di log\r\n        setConfiguration(this._stackLog.pop());\r\n\r\n        //Diminuisci il counter delle mosse\r\n        _moveCounter--;\r\n    }\r\n\r\n    /**\r\n     * Metodo che setta il numero della configurazione iniziale\r\n     *\r\n     * @throws IllegalArgumentException se configurationNumber non è compreso tra 1 e 4\r\n     */\r\n    private void setInitialSelectedConf(int i) {\r\n        if (i < 1 || i > 4) {\r\n            throw new IllegalArgumentException(\"configurationNumber non compreso tra 1 e 4\");\r\n        }\r\n\r\n        this._initialSelectedConf = i;\r\n    }\r\n\r\n    /**\r\n     * Metodo che estrapola la configurazione iniziale, associata alla configurazione corrente, dal log.\r\n     *\r\n     * @return initConf configurazione iniziale estrapolata.\r\n     */\r\n    private Configuration getInitConfiguration() {\r\n        Stack<Configuration> utility = new Stack<>();\r\n        int s = _stackLog.size();\r\n        for (int i = 1; i < s; i++) {\r\n            utility.push(_stackLog.pop());\r\n        }\r\n        UtilityJackson.serializeConfiguration(_stackLog.peek(), _supportFilePathName);\r\n        s = utility.size();\r\n        for (int i = 0; i < s; i++) {\r\n            _stackLog.push(utility.pop());\r\n        }\r\n        return UtilityJackson.deserializeConfiguration(_supportFilePathName);\r\n    }\r\n\r\n    /**\r\n     * Metodo che converte la configurazione attuale in json e la inserisce sia nello Stack log che nel file log\r\n     */\r\n    private void updateLogsWithCurrentConfiguration() {\r\n        //Serializza la configurazione corrente nel file di supporto\r\n        UtilityJackson.serializeConfiguration(_configuration, _supportFilePathName);\r\n        //Deserializza la configurazione corrente dal file di supporto e inseriscila nello Stack log\r\n        _stackLog.push(UtilityJackson.deserializeConfiguration(_supportFilePathName));\r\n        //Scrivi tutto lo Stack di log sul file di log\r\n        UtilityJackson.serializeConfigurationLog(_stackLog, _logFilePathName);\r\n\r\n    }\r\n\r\n    /**\r\n     * Controlla che la configurazione attuale non rappresenti una situazione di vittoria\r\n     * @throws Exception se invece è una situazione di vittoria\r\n     */\r\n    private void checkNotWin() throws Exception{\r\n        //Prende il pezzo piu' grande (che è sempre il primo)\r\n        Piece pieceToCheck = _configuration.getPieces()[0];\r\n\r\n        //Se si trova nella posizione di vittoria\r\n        if (pieceToCheck.getLayoutX() == WIN_X && pieceToCheck.getLayoutY() == WIN_Y) {\r\n            int oldCounter = this._moveCounter;\r\n            //Resetta il gioco\r\n            this.reset();\r\n            //avvisa che è stato vinto il gioco in oldCounter mosse\r\n            throw new Exception(String.valueOf(oldCounter));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Metodo per muovere un pezzo della configurazione attuale del gioco in basso\r\n     *\r\n     * @param piece pezzo da muovere\r\n     * @throws IllegalArgumentException se il pezzo non appartiene alla configurazione attuale del gioco\r\n     */\r\n    private void movePieceDown(Piece piece) {\r\n\r\n        //Verifica che il pezzo appartenga alla configurazione\r\n        if (!_configuration.doesPieceBelong(piece)) {\r\n            throw new IllegalArgumentException(\"Il pezzo non appartiene alla configurazione attuale del gioco\");\r\n        }\r\n\r\n        //Muove in giù il pezzo\r\n        piece.setLayoutY(piece.getLayoutY() + Constants.MOVE_AMOUNT);\r\n\r\n        //Incrementa il counter delle mosse\r\n        this._moveCounter++;\r\n\r\n        //La configurazione attuale (_configuration) si aggiorna automaticamente il pezzo spostato\r\n\r\n        //Aggiorna lo stack di log e il file di log con la nuova configurazione attuale\r\n        updateLogsWithCurrentConfiguration();\r\n    }\r\n\r\n    /**\r\n     * Metodo per muovere un pezzo della configurazione attuale del gioco in alto\r\n     *\r\n     * @param piece pezzo da muovere\r\n     * @throws IllegalArgumentException se il pezzo non appartiene alla configurazione attuale del gioco\r\n     */\r\n    private void movePieceUp(Piece piece) {\r\n\r\n        //Verifica che il pezzo appartenga alla configurazione\r\n        if (!_configuration.doesPieceBelong(piece)) {\r\n            throw new IllegalArgumentException(\"Il pezzo non appartiene alla configurazione attuale del gioco\");\r\n        }\r\n        //Muove in su il pezzo\r\n        piece.setLayoutY(piece.getLayoutY() - Constants.MOVE_AMOUNT);\r\n\r\n        //Incrementa il counter delle mosse\r\n        this._moveCounter++;\r\n\r\n        //La configurazione attuale (_configuration) si aggiorna automaticamente il pezzo spostato\r\n\r\n        //Aggiorna lo stack di log e il file di log con la nuova configurazione attuale\r\n        updateLogsWithCurrentConfiguration();\r\n    }\r\n\r\n\r\n    /**\r\n     * Metodo per muovere un pezzo della configurazione attuale del gioco a sx\r\n     *\r\n     * @param piece pezzo da muovere\r\n     * @throws IllegalArgumentException se il pezzo non appartiene alla configurazione attuale del gioco\r\n     */\r\n    private void movePieceLeft(Piece piece) {\r\n\r\n        //Verifica che il pezzo appartenga alla configurazione\r\n        if (!_configuration.doesPieceBelong(piece)) {\r\n            throw new IllegalArgumentException(\"Il pezzo non appartiene alla configurazione attuale del gioco\");\r\n        }\r\n        //Muovi a sx il pezzo\r\n        piece.setLayoutX(piece.getLayoutX() - Constants.MOVE_AMOUNT);\r\n\r\n        //Incrementa il counter delle mosse\r\n        this._moveCounter++;\r\n\r\n        //La configurazione attuale (_configuration) si aggiorna automaticamente il pezzo spostato\r\n\r\n        //Aggiorna lo stack di log e il file di log con la nuova configurazione attuale\r\n        updateLogsWithCurrentConfiguration();\r\n    }\r\n\r\n    /**\r\n     * Metodo per muovere un pezzo della configurazione attuale del gioco a dx\r\n     *\r\n     * @param piece pezzo da muovere\r\n     * @throws IllegalArgumentException se il pezzo non appartiene alla configurazione attuale del gioco\r\n     */\r\n    private void movePieceRight(Piece piece) {\r\n        //Verifica che il pezzo appartenga alla configurazione\r\n        if (!_configuration.doesPieceBelong(piece)) {\r\n            throw new IllegalArgumentException(\"Il pezzo non appartiene alla configurazione attuale del gioco\");\r\n        }\r\n        //Muovi a dx il pezzo\r\n        piece.setLayoutX(piece.getLayoutX() + Constants.MOVE_AMOUNT);\r\n\r\n        //Incrementa il counter delle mosse\r\n        this._moveCounter++;\r\n\r\n        //La configurazione attuale (_configuration) si aggiorna automaticamente il pezzo spostato\r\n\r\n        //Aggiorna lo stack di log e il file di log con la nuova configurazione attuale\r\n        updateLogsWithCurrentConfiguration();\r\n    }\r\n}\r\n
===================================================================
diff --git a/src/main/java/com/klotski/app/Game.java b/src/main/java/com/klotski/app/Game.java
--- a/src/main/java/com/klotski/app/Game.java	
+++ b/src/main/java/com/klotski/app/Game.java	
@@ -331,7 +331,6 @@
         _stackLog.push(UtilityJackson.deserializeConfiguration(_supportFilePathName));
         //Scrivi tutto lo Stack di log sul file di log
         UtilityJackson.serializeConfigurationLog(_stackLog, _logFilePathName);
-
     }
 
     /**
